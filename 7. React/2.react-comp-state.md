# 리액트 컴포넌트와 상태 관리

## 컴포넌트

- **컴포넌트란?**: UI를 구성하는 재사용 가능한 독립적인 구성 요소
- **함수형 컴포넌트**:

  ```javascript
  function ComponentName(props) {
    return <jsx />;
  }
  ```

- 상태 관리: `useState` 훅 사용.

- **클래스형 컴포넌트**:

  ```javascript
  import { Component } from 'react';

  class ComponentName extends Component {
    render() {
      return <jsx />;
    }
  }
  ```

  - 상태 관리: 생성자의 `this.state` 사용

## 상태 관리

- **양방향 데이터 바인딩**: 상태 변경 시 UI 자동 업데이트.

- **상태 객체**: 여러 상태를 객체로 묶어서 관리하는 것이 효율적임.

## PropTypes

- `propTypes`를 사용하여 props의 타입을 지정할 수 있음.

## 예시: 상태 관리

```javascript
import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
};
```

## 마운트란

돔이 생성되고 웹브라우저 상에 나타는것

[클래스형 컴포넌트]
리액트는 렌더가 된 후에 마운트가 된다(componentDidMount()). 사용자가 기다리는 시간을 줄이기 위해 !

- constructor()
- getDerivedStateFromProps()
- render()
- componentDidMount()

[함수형 컴포넌트]
비동기를 통해 리렌더링한다.

- **마운트 업데이트를 발생시키는 요인**:

  1. 자신의 상태가 변경될 때

  - props
  - state

  2. 부모 컴포넌트 리렌더링

### 업데이트할때 호출하는 메서드

shouldComponentUpdate()에서 ture가 기본값이다, 단, false를 반환하면 업데이트 과정은 여기서 중지된다. => 부모가 리렌더링되어도 자식 컴포넌트를 변화시키지 않고 싶을때 오버라이드해서 사용한다.
=> 이럴때 useMemo 사용:

라이프 사이클 콜백 함수가 두번씩 실행되는 이유?

- - StrictMode를 사용할 경우 개발 모드에서 부작용(side effect) 감지를 위한 React의 의도적인 동작으로
- 특정 라이프 사이클 콜백만 두번씩 실행 시킨다.
- - 배포를 하게되면 정상적으로 한번씩만 수행된다.

(사진)
[참고링크](https://codesandbox.io/p/sandbox/currying-bash-mrkjb?file=%2Fsrc%2FLifeCycleSample.js%3A7%2C5)

### 빌드법

- 배포하기
- npm run build
-
- 서버 설치하기
- npm install -g serve
-
- 서버 실행하기
- serve -s build http://localhost:3000 으로 접속할 수 있다.
