# 자바 기본 문법

## main() 메소드

> 프로그램의 시작점

## 입력

- `BufferedReader br = new BufferedReader(new InputStreamReader(System.in));`
  - 키보드로부터 입력(default)
- `System.setIn(new FileInputStream("input.txt"));`
  - 파일로부터 입력
- `StringTokenizer st = new StringTokenizer(br.readLine());`
  - 공백을 기준으로 문자열을 나눠서 저장
  - `st.nextToken()`: 다음 토큰을 반환
- `Scanner sc = new Scanner(System.in);`
  - 키보드로부터 입력
  - `sc.nextInt()`: 정수 입력
  - `sc.next()`: 문자열 입력
  - `sc.nextLine()`: 문자열 입력(공백 포함)
  - `sc.close()`: 스캐너 닫기

## 출력

- `print`: 명령창에 출력하며, 엔터 없이 옆으로 이어서 출력한다.
- `println`: 명령창에 출력한 후 엔터를 통해 다음 줄로 넘어간다.

  ```java
  System.out.print("hello ");
  System.out.println("world ");
  ```

- `printf(format, data)`:
  - `%d` : 정수
  - `%f` : 실수
  - `%s` : 문자열
  - `%c` : 문자
  - `%b` : 논리값
  - `%n` : 줄바꿈

## 타입

문자열(String) 객체는 변경할 수 없다.

- 연산 시 기존 객체를 버리고 새로 생성하는 방식이므로 성능 저하의 원인이 될 수 있다.

### 문자열 변경하기

- **StringBuilder**:
  - 문자열을 변경할 수 있는 객체
  - 많은 양의 문자열을 다룰 때 유용하다.
  - `append`: 저장된 내용의 맨 끝에 추가할 수 있다.

### 기본형 타입 (Primitive Type)

- **정수형**: `byte`, `short`, `int`, `long`

  - 기본형: `int`
  - byte, short의 변수를 연산 시 int로 형변환 시킨다.

  ```java
  	byte b1 = 1;
  	byte b2 = 2;
  	int b3 = b1 + b2;
  	// byte b3 = b1 + b2;
  	byte b4 = (byte)(b1+b2);
  ```

  - long 타입은 l 또는 L을 붙여야 한다.

- **문자형**: `char`
  - 2Byte
  - 'A' = 65, 'a' = 97
- **실수형**: `float`, `double`
  - 0~1사이의 무한 실수가 있기 때문에 double은 8Byte로, float는 4Byte로 근사치를 표현한다.
  - float 타입이 double 타입보다 더 큰 범위를 표현할 수 있다.
- **논리형**: `boolean`

### 참조형 타입 (Reference Type)

- 사용자 정의 데이터 타입
- **객체**: `class`, `interface`, `enum`, 배열 등

## 변수 선언

```java
datatype variableName = value;
```

### 변수의 선언 과정

1. **변수의 할당**:

   - 변수를 선언한 후, 값을 할당하는 과정이 있습니다. 이때 객체나 기본값이 변수에 할당됩니다.
   - 기본 타입의 변수(예: `int`, `char`)는 값이 직접 저장되고, 객체 타입의 변수는 객체의 참조값이 저장됩니다.

2. **메모리 할당**:

   - 변수가 객체 타입일 경우, 객체가 힙(Heap) 메모리에 저장됩니다. 이 힙 메모리는 동적으로 할당되며, 객체의 생명주기가 다할 때까지 유지됩니다.

3. **참조값(해시코드) 저장**:

   - 변수에 객체를 할당하면, 할당된 공간에는 그 객체를 참조할 수 있는 참조값(또는 해시코드)이 저장됩니다. 이 참조값은 실제 객체가 저장된 힙 메모리의 주소를 의미합니다.
   - 예를 들어, `MyClass obj = new MyClass();`에서 `obj`에는 `MyClass` 객체가 저장된 메모리 주소가 저장됩니다.

4. **메모리 힙으로 이동**:
   - 변수가 할당될 때, 메모리에 실제 객체가 생성되고 힙 영역에 저장됩니다. 이후 이 변수를 통해 그 객체에 접근할 수 있습니다.
   - 변수는 객체의 참조값을 통해 메모리 내의 객체와 연결되므로, 변수를 사용하여 객체의 속성과 메서드에 접근할 수 있습니다.

## 비트 연산

### 논리 연산자

- `&` : and
  - 연산하려는 두 비트가 모두 1일 때 1이고, 나머지는 0
  - 특정 위치에 1이 있는지 체크 용도로 사용
  - 0과 & 시 데이터를 0으로 초기화 가능
- `|` : or
  - 특정 위치에 원소 추가(1로 마스킹) 효과
  - 두비트가 모두 0일때만 0, 나머지는 1
- `^` : xor
  - 두 비트가 같으면 0 다르면 1 ==> 토글 효과
- `~` : not
  - 비트 반전()

### 비트 시프트 연산

- `data << 이동시킬 비트수`: 지정한 수만큼 왼쪽으로 이동
- `data >> 이동시킬 비트수`: 지정한 수만큼 오른쪽으로 이동
  => 2^이동수만큼 곱한 효과

### 비트 마스크

> 기존의 bit를 비트 연산자(&, |, ^, ~, <<, >>)를 이용해서 다른 값으로 변경(masking)하는 작업

- 정수의 이진수 표현을 자료구조로 쓰는 기법
  => boolean 배열을 대체하는 효과

  - 보통 어떤 비트가 1이면 '켜져있다, true, 해당 위치에 원소가 있다'는 것을 나타냄.
  - 0이면 '꺼져있다, false, 해당 위치에 원소가 없다'는 것을 나타냄.

- 장점

  - 수행 속도가 빠르다

    - 비트 마스크 연산은 bit 연산(&, |, ^, ~)이므로 O(1) 연산
    - => 다른 자료구조(boolean 배열)를 이용하는 것보다 빠르게 동작한다.

    - _ex. 10만개의 word에 a, k, g가 있는지 체크?_

      - boolean 배열 : O(10만 * word의 크기) => O(n*word의 크기)

      ```java
      for(int i=0; i< 100000; i++) {
        int count = 0 ;
        for(int j = 0; size = word.length(); j <size; j++) {
          if(word.charAt(j)=='a' || word.charAt(j)=='a' ||word.charAt(j)=='a' )
            count ++;
          if(count==3)
          result++;
      }
      }
      ```

    - 비트 마스크 : O(10만) => O(n)
      ```java
      for(int i=0; i< 100000; i++) {
        if(word & key = key){
          result++;
        }
      }
      ```

  - 코드 길이가 짧아진다.

    - boolean 배열을 모두 순회해서 체크하는 코드가 bit 연산 하나로 대체될수 있으므로 코드가 간결해진다.

  - 메모리 사용량이 적다.

    - _ex. 문이 잠긴 행, 열로 구성된 map에서 key(a, b, c, d, e, f)를 이용해서 문을 열어야 도착점으로 탈출할 수 있는 경우, 방문 체크 배열?_

      - boolean 배열 : [행][열][a][b][c][d][e][f] ==> 8차원 배열 선언 필요

      - bit mash: [행][열][key] ==> 3차원 배열만 있어도 됨.

## 형변환(Cast)

> 데이터 타입을 변환

논리(boolean) 타입을 제외한 나머지 타입들은 서로 형변환이 가능하다.

### 자동 형변환

JVM에서 자동으로 형변환된다.
ex. byte -> short -> int -> long -> float -> double

### 명시적 형변환

자동으로 형변환 안되므로 명시적으로 형변환해야한다.

- 형식
  - (데이터 타입) 값;

## 람다 표현식 요약

- **정의**:
  자바 8에서 도입된 익명 함수로, 코드를 간결하게 작성할 수 있다.
  코드 가독성을 높이고, 함수형 프로그래밍 스타일을 활용할 수 있음.
  - 자바스크립트의 화살표 함수같은 역할
- **형식**:

  ```
  () -> { }
  ```

- **구성 요소**:

  - **인자**:

    - 단일 인자: `x -> {x * x}`
    - 여러 인자: `(x, y) -> {x + y}`

### **컬렉션 프레임워크 (Collection Framework)**

| 인터페이스 | 구현 클래스               | 특징                 |
| ---------- | ------------------------- | -------------------- |
| `List`     | `ArrayList`, `LinkedList` | 순서 유지, 중복 허용 |
| `Set`      | `HashSet`, `TreeSet`      | 순서 없음, 중복 불가 |
| `Map`      | `HashMap`, `TreeMap`      | 키-값 쌍 저장        |
