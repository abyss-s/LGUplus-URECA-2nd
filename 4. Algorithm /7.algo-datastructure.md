# 스택(Stack)

> LIFO(Last In First Out)

- 시간복잡도
  - 삽입: O(1)
  - 삭제: O(1)
  - 검색: O(n)

# 큐(Queue)

> FIFO(First In First Out)

- 시간복잡도
  - 삽입: O(1)
  - 삭제: O(1)
  - 검색: O(n)

# 링크드리스트(LinkedList)

> 데이터를 담고 있는 노드들이 연결되어 있는 방식의 자료구조

# 트리(Tree)

> 사이클이 없고, 방향이 정해져 있는 그래프

![트리](https://i.namu.wiki/i/8pViDtKiYxEmcz1zj2WHZEpLHeu4q4n1bAjOOTvA4rLde3d-miR4lbCeFRjhzuTV1SLW5vFdg81Q6vb6fm1I9Q.webp)

## 트리 용어

- root: 최상위 노드
- leaf: 자식이 없는 노드
- degree(차수) : 노드의 자식 수
- level(레벨) : 루트로부터의 거리 (0부터 시작)

## 이진트리(Binary Tree)

- 왼쪽 자식: 부모 인덱스 \* 2
- 오른쪽 자식: 부모 인덱스 \* 2 + 1

## 완전 이진트리(Complete Binary Tree)

세그먼트 트리와 힙을 이용하면 완전 이진트리를 구현할 수 있다.

n이 너무 클때, 시간복잡도를 O(log n)으로 줄이기 위해 사용해보자!

### 세그먼트 트리(Segment Tree)

> 배열의 특정 구간의 합을 구하는 문제에 사용

### 힙(Heap)

> 최대값, 최소값을 빠르게 찾기 위해 사용

# 그래프(Graph)

> 원소와 원소 간의 연결 관계를 표현한 자료구조

![그래프](https://chamdom.blog/static/43dcc5ebdae930f808c5563ac31f4159/c5bb3/directed-and-undirected.png)

- 정점(Vertex)과 간선(Edge)으로 구성되어 있다.
- 무방향 그래프, 방향 그래프, 가중치 그래프 등의 종류가 있다.

## 인접 리스트(Adjacency List)

> 연결되어 있는 원소 간 정보를 표현한 자료구조.

행은 원소, 열은 원소 간 연결 정보를 나타낸다.

| 연결      | 비연결          |
| --------- | --------------- |
| true      | false           |
| 1         | 0               |
| cost 존재 | cost 존재 X (0) |

## 인접 행렬(Adjacency Matrix)

> 원소 간 연결 정보를 행렬로 표현한 자료구조.

- 행과 열은 원소를 나타내고, 행렬의 값은 원소 간 연결 정보를 나타낸다.
- 가중치 그래프의 경우 행렬의 값은 가중치를 나타내기도 한다.

| Node 수 | 인접 행렬 크기   | 배열 크기   | 메모리     | 수행횟수                                  |
| ------- | ---------------- | ----------- | ---------- | ----------------------------------------- |
| 100     | 100 \* 100       | 10,000      | 10K, 40K   | 10,000                                    |
| 1,000   | 1,000 \* 1,000   | 1,000,000   | 10M, 40M   | 1,000,000                                 |
| 10,000  | 10,000 \* 10,000 | 100,000,000 | 100M, 400M | 1억(인접행렬로는 메모리 초과로 사용 불가) |

# 그래프 탐색

## 깊이 우선 탐색(Depth First Search, DFS)

> stack 이용하기

- 최소 비용 구하기
  - 시작에서 끝까지 가는 모든 방법의 수를 구할 때 사용

## 너비 우선 탐색(Breadth First Search, BFS)

> queue 이용하기

- 최소 비용 구하기
  - 가중치가 없는 map에서 시작에서 끝까지 최소 비용(거리)을 구할 때 사용
    - 시간복잡도: `O(n)`
  - 특정 위치에서 점진적으로 퍼져나가는 문제를 해결하기 위해 사용한다.

## 다익스트라()

- 가중치가 있는 map에서 시작에서 끝까지 최소 비용(거리)을 구할 때 사용
  - 시간복잡도: `O(n^2)`

## 플로이드 워셜

- 모든 노드들의 최소 비용을 구함
- n의 개수가 적을 때 사용
- 시간복잡도: `O(n^3)`
