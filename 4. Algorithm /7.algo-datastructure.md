# 스택(Stack)

> LIFO(Last In First Out)

- 시간복잡도
  - 삽입: O(1)
  - 삭제: O(1)
  - 검색: O(n)

# 큐(Queue)

> FIFO(First In First Out)

- 시간복잡도
  - 삽입: O(1)
  - 삭제: O(1)
  - 검색: O(n)

# 링크드리스트(LinkedList)

> 데이터를 담고 있는 노드들이 연결되어 있는 방식의 자료구조

# 트리(Tree)

> 사이클이 없고, 방향이 정해져 있는 그래프

![트리](https://i.namu.wiki/i/8pViDtKiYxEmcz1zj2WHZEpLHeu4q4n1bAjOOTvA4rLde3d-miR4lbCeFRjhzuTV1SLW5vFdg81Q6vb6fm1I9Q.webp)

## 트리 용어

- root: 최상위 노드
- leaf: 자식이 없는 노드
- degree(차수) : 노드의 자식 수
- level(레벨) : 루트로부터의 거리 (0부터 시작)

## 이진트리(Binary Tree)

- 왼쪽 자식: 부모 인덱스 \* 2
- 오른쪽 자식: 부모 인덱스 \* 2 + 1

## 완전 이진트리(Complete Binary Tree)

세그먼트 트리와 힙을 이용하면 완전 이진트리를 구현할 수 있다.

n이 너무 클때, 시간복잡도를 O(log n)으로 줄이기 위해 사용해보자!

## 최소 신장 트리(Minimum Spanning Tree)

> 신장 트리 중 간선의 가중치 합이 최소인 신장 트리

![mst](https://velog.velcdn.com/images%2Fjminkyoung%2Fpost%2F71743950-fa92-4be7-9e1b-f4e6c6e7880c%2Fimage.png)

- 완전탐색이 불가하기 때문에, 현재 시점에서 가장 좋은 방법을 선택하는 **그리디 알고리즘**을 활용하자!

- **신장 트리(Spanning Tree)**

  - 그래프의 모든 노드를 포함하면서 사이클이 존재하지 않는 무방향 그래프
  - n개의 정점과 n-1개의 간선으로 이루어져 있다.

### 최소 신장 트리 구현 방법

> **크루스칼 알고리즘(Kruskal's Algorithm)**

- 간선(Edge)의 비용을 이용해서 오름차순으로 정렬한다.

- 비용이 적은 간선 부터 V-1개의 간선을 선택해 신장트리를 만든다.

- 간선을 선택할 때 cycle이 생기지 않는지 check해서, cycle이 생기지 않는 간선인 경우 선택하고 해당 비용을 누적한다.

  - why?? cycle의 유무에 따라 트리와 그래프 구분 가능하기 때문!
    - cycle이 있으면 그래프
    - cycle이 없으면 트리

- 시간복잡도

  - makeSet(): `O(v)`
  - edges.sort(): `O(e log e)`
  - union : `O(V+ 2*union(E,E))` => `O(E)`
  - find: `O(e log e)`

[참고자료](https://lazyhysong.tistory.com/entry/JS-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-Minimum-Spanning-Tree-Kruskal)

#### 서로소 집합(Disjoint Set), Union-Find

> 집합에 속한 하나의 특정 멤버(대표자 `root`)를 통해 각 집합들을 구분한다.

![서로소집합](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpiR0m%2Fbtq6eGhdhQG%2FeILD9IKUQh3zvuTm0Kkgfk%2Fimg.png)

- 방법

  1. `makeset(x)` : x를 원소로 갖는 최소 단위 집합 만들기
     => 각 원소의 root를 자기 자신으로 설정한다.

  2. `findset(x)` : x원소의 root를 찾는 함수

     - `path compression`: x의 root를 따라가면서 root를 찾는다.
     - `rank`를 이용한 `union by rank`: x의 root와 y의 root를 비교하여 rank가 더 큰 집합의 root를 작은 집합의 root로 만든다.

  3. `union(x, y)`: x의 집합과 y의 집합을 합친다.
     => x의 root를 찾고 y의 root를 찾아 두 집합 중 하나의 집합의 root를 한 다른 하나의 집합의 원소로 만든다.

- 시간복잡도: `O(V+E)`

  - 최악의 경우 2N(초기 make 횟수+pathCompression횟수) + 2(루트까지 find하는 횟수) \* 유니온 횟수(E)

- 응용: MST(최소 신장 트리)의 크루스칼 알고리즘에 적용

### 세그먼트 트리(Segment Tree)

> 배열의 특정 구간의 합을 구하는 문제에 사용

### 힙(Heap)

> 최대값, 최소값을 빠르게 찾기 위해 사용

# 그래프(Graph)

> 원소와 원소 간의 연결 관계를 표현한 자료구조

![그래프](https://chamdom.blog/static/43dcc5ebdae930f808c5563ac31f4159/c5bb3/directed-and-undirected.png)

- 정점(Vertex)과 간선(Edge)으로 구성되어 있다.

- 무방향 그래프, 방향 그래프, 가중치 그래프 등의 종류가 있다.

## 인접 리스트(Adjacency List)

> 연결되어 있는 원소 간 정보를 표현한 자료구조.

행은 원소, 열은 원소 간 연결 정보를 나타낸다.

| 연결      | 비연결          |
| --------- | --------------- |
| true      | false           |
| 1         | 0               |
| cost 존재 | cost 존재 X (0) |

## 인접 행렬(Adjacency Matrix)

> 원소 간 연결 정보를 행렬로 표현한 자료구조.

- 행과 열은 원소를 나타내고, 행렬의 값은 원소 간 연결 정보를 나타낸다.
- 가중치 그래프의 경우 행렬의 값은 가중치를 나타내기도 한다.

| Node 수 | 인접 행렬 크기   | 배열 크기   | 메모리     | 수행횟수                                  |
| ------- | ---------------- | ----------- | ---------- | ----------------------------------------- |
| 100     | 100 \* 100       | 10,000      | 10K, 40K   | 10,000                                    |
| 1,000   | 1,000 \* 1,000   | 1,000,000   | 10M, 40M   | 1,000,000                                 |
| 10,000  | 10,000 \* 10,000 | 100,000,000 | 100M, 400M | 1억(인접행렬로는 메모리 초과로 사용 불가) |

# 그래프 탐색

## 깊이 우선 탐색(Depth First Search, DFS)

> stack 이용하기

- 최소 비용 구하기
  - 시작에서 끝까지 가는 모든 방법의 수를 구할 때 사용

## 너비 우선 탐색(Breadth First Search, BFS)

> queue 이용하기

- 최소 비용 구하기
  - 가중치가 없는 map에서 시작에서 끝까지 최소 비용(거리)을 구할 때 사용
    - 시간복잡도: `O(n)`
  - 특정 위치에서 점진적으로 퍼져나가는 문제를 해결하기 위해 사용한다.

## 다익스트라()

- 가중치가 있는 map에서 시작에서 끝까지 최소 비용(거리)을 구할 때 사용
  - 시간복잡도: `O(n^2)`

## 플로이드 워셜

- 모든 노드들의 최소 비용을 구함
- n의 개수가 적을 때 사용
- 시간복잡도: `O(n^3)`
