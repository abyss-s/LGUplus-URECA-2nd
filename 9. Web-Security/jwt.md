# JWT (JSON Web Token)

## 1. 기존 Cookie나 Session을 통한 인증의 문제점

### 쿠키(Cookie)

- 민감한 정보(id, pw 등)가 노출될 위험이 있음 → 보안에 취약
- 브라우저마다 쿠키 지원 방식이 달라 브라우저 간 공유가 불가
- 쿠키 크기가 커질수록 네트워크 부하 증가

### 세션(Session)

- 세션 저장소에 문제가 생기면 인증 체계가 무너짐
- **stateful**하므로 HTTP의 stateless 특성을 살리지 못하고 확장성에 한계
- 세션 저장소 구축 및 유지 비용이 발생
- 세션 ID가 쿠키로 저장되어 탈취 위험 존재
- 사용자가 많아질수록 메모리 사용량 증가
- 매 요청 시마다 세션 저장소 조회가 필요

## 2. JWT란?

- 인증 정보를 JSON 형태로 암호화한 토큰
- 공개 키 / 개인 키를 쌍으로 사용
- 전자서명(Signature)을 포함하여 위변조 방지 가능
- 세션 저장소가 필요 없어 **stateless** → 확장성 우수

## 3. JWT 구조

`Header.Payload.Signature` 형태로 구성됨

### 3.1 Header

- 토큰 타입 (`typ`)과 해싱 알고리즘 (`alg`) 명시
- 예시:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 3.2 Payload (클레임 정보)

- 토큰에 담을 정보 **claim**를 name/value 쌍으로 구성
- **주의**: Payload는 인코딩(B64)만 되어 있어 누구나 디코딩 가능 → 민감 정보 X

#### 클레임 종류

- **등록된(Registered) 클레임**: 사전에 정의된 표준 클레임
  | 클레임 | 설명 |
  |--------|------|
  | `iss` | 발급자 |
  | `sub` | 제목 |
  | `aud` | 대상자 |
  | `exp` | 만료 시간 |
  | `nbf` | Not Before (활성화 시작 시점) |
  | `iat` | 발급 시간 |
  | `jti` | 토큰 고유 ID |

- **공개(Public) 클레임**: URI 형식으로 충돌 방지
- **비공개(Private) 클레임**: 서버-클라이언트 간 약속된 값, 충돌 주의

### 3.3 Signature

- `header` + `payload`를 인코딩 후 비밀키로 해싱하여 생성
- 서버만 서명 검증 가능 → 위조 방지

## 4. 장점과 단점

### 장점

- 세션 저장소 불필요
- 서버가 클라이언트 상태를 저장할 필요 없음
- 서명으로 무결성 보장
- 다양한 서비스 간 공통 인증 수단으로 활용 가능

### 단점

- Payload는 암호화되지 않아 정보 노출 위험 → 민감 정보 저장 금지
  - 해결 방법: JWE(JSON Web Encryption)
- 토큰 탈취 시 만료 전까지 차단 불가 → 유효 시간 짧게 설정 필요

### 보완 방안

- **Sliding Session**: 사용자 활동 시 만료 시간 갱신
  ex. 글쓰기 중일때는 작성자의 만료시간을 연장해준다.
- **Refresh Token**: Access Token 만료 시 재발급용으로 사용

## Spring Boot에서 JWT 적용 흐름

1. 사용자가 로그인하여 JWT를 발급받음
2. JWT는 클라이언트의 쿠키에 저장되거나 Authorization 헤더에 포함됨
3. 클라이언트가 요청을 보낼 때마다 JWT를 포함하여 서버로 전송
4. 서버는 JWT의 유효성을 검사하고, 유효하다면 요청을 처리
5. 만약 JWT가 만료되었으면, Refresh Token을 사용하여 새로운 JWT 발급
